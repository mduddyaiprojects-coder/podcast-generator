"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStoreService = void 0;
const backend_common_1 = require("@n8n/backend-common");
const di_1 = require("@n8n/di");
const n8n_workflow_1 = require("n8n-workflow");
const data_store_column_repository_1 = require("./data-store-column.repository");
const data_store_rows_repository_1 = require("./data-store-rows.repository");
const data_store_repository_1 = require("./data-store.repository");
const data_store_types_1 = require("./data-store.types");
const data_store_column_not_found_error_1 = require("./errors/data-store-column-not-found.error");
const data_store_name_conflict_error_1 = require("./errors/data-store-name-conflict.error");
const data_store_not_found_error_1 = require("./errors/data-store-not-found.error");
const data_store_validation_error_1 = require("./errors/data-store-validation.error");
const sql_utils_1 = require("./utils/sql-utils");
let DataStoreService = class DataStoreService {
    constructor(dataStoreRepository, dataStoreColumnRepository, dataStoreRowsRepository, logger) {
        this.dataStoreRepository = dataStoreRepository;
        this.dataStoreColumnRepository = dataStoreColumnRepository;
        this.dataStoreRowsRepository = dataStoreRowsRepository;
        this.logger = logger;
        this.logger = this.logger.scoped('data-table');
    }
    async start() { }
    async shutdown() { }
    async createDataStore(projectId, dto) {
        await this.validateUniqueName(dto.name, projectId);
        return await this.dataStoreRepository.createDataStore(projectId, dto.name, dto.columns);
    }
    async updateDataStore(dataStoreId, projectId, dto) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        await this.validateUniqueName(dto.name, projectId);
        await this.dataStoreRepository.update({ id: dataStoreId }, { name: dto.name });
        return true;
    }
    async deleteDataStoreByProjectId(projectId) {
        return await this.dataStoreRepository.deleteDataStoreByProjectId(projectId);
    }
    async deleteDataStoreAll() {
        return await this.dataStoreRepository.deleteDataStoreAll();
    }
    async deleteDataStore(dataStoreId, projectId) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        await this.dataStoreRepository.deleteDataStore(dataStoreId);
        return true;
    }
    async addColumn(dataStoreId, projectId, dto) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        return await this.dataStoreColumnRepository.addColumn(dataStoreId, dto);
    }
    async moveColumn(dataStoreId, projectId, columnId, dto) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        const existingColumn = await this.validateColumnExists(dataStoreId, columnId);
        await this.dataStoreColumnRepository.moveColumn(dataStoreId, existingColumn, dto.targetIndex);
        return true;
    }
    async deleteColumn(dataStoreId, projectId, columnId) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        const existingColumn = await this.validateColumnExists(dataStoreId, columnId);
        await this.dataStoreColumnRepository.deleteColumn(dataStoreId, existingColumn);
        return true;
    }
    async getManyAndCount(options) {
        return await this.dataStoreRepository.getManyAndCount(options);
    }
    async getManyRowsAndCount(dataStoreId, projectId, dto) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        const columns = await this.dataStoreColumnRepository.getColumns(dataStoreId);
        if (dto.filter) {
            this.validateAndTransformFilters(dto.filter, columns);
        }
        const result = await this.dataStoreRowsRepository.getManyAndCount(dataStoreId, dto, columns);
        return {
            count: result.count,
            data: (0, sql_utils_1.normalizeRows)(result.data, columns),
        };
    }
    async getColumns(dataStoreId, projectId) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        return await this.dataStoreColumnRepository.getColumns(dataStoreId);
    }
    async insertRows(dataStoreId, projectId, rows, returnData) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        await this.validateRows(dataStoreId, rows);
        const columns = await this.dataStoreColumnRepository.getColumns(dataStoreId);
        return await this.dataStoreRowsRepository.insertRows(dataStoreId, rows, columns, returnData);
    }
    async upsertRow(dataStoreId, projectId, dto, returnData = false) {
        const updated = await this.updateRow(dataStoreId, projectId, dto, true);
        if (updated.length > 0) {
            return returnData ? updated : true;
        }
        const inserted = await this.insertRows(dataStoreId, projectId, [dto.data], returnData);
        return returnData ? inserted : true;
    }
    async updateRow(dataTableId, projectId, dto, returnData = false) {
        await this.validateDataStoreExists(dataTableId, projectId);
        const columns = await this.dataStoreColumnRepository.getColumns(dataTableId);
        if (columns.length === 0) {
            throw new data_store_validation_error_1.DataStoreValidationError('No columns found for this data table or data table not found');
        }
        const { data, filter } = dto;
        if (!filter?.filters || filter.filters.length === 0) {
            throw new data_store_validation_error_1.DataStoreValidationError('Filter must not be empty');
        }
        if (!data || Object.keys(data).length === 0) {
            throw new data_store_validation_error_1.DataStoreValidationError('Data columns must not be empty');
        }
        this.validateRowsWithColumns([data], columns, false);
        this.validateAndTransformFilters(filter, columns);
        return await this.dataStoreRowsRepository.updateRow(dataTableId, data, filter, columns, returnData);
    }
    async deleteRows(dataStoreId, projectId, ids) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        return await this.dataStoreRowsRepository.deleteRows(dataStoreId, ids);
    }
    validateRowsWithColumns(rows, columns, includeSystemColumns = false) {
        const allColumns = includeSystemColumns
            ? [
                { name: 'id', type: 'number' },
                { name: 'createdAt', type: 'date' },
                { name: 'updatedAt', type: 'date' },
                ...columns,
            ]
            : columns;
        const columnNames = new Set(allColumns.map((x) => x.name));
        const columnTypeMap = new Map(allColumns.map((x) => [x.name, x.type]));
        for (const row of rows) {
            const keys = Object.keys(row);
            for (const key of keys) {
                if (!columnNames.has(key)) {
                    throw new data_store_validation_error_1.DataStoreValidationError(`unknown column name '${key}'`);
                }
                this.validateCell(row, key, columnTypeMap);
            }
        }
    }
    async validateRows(dataStoreId, rows, includeSystemColumns = false) {
        const columns = await this.dataStoreColumnRepository.getColumns(dataStoreId);
        this.validateRowsWithColumns(rows, columns, includeSystemColumns);
    }
    validateCell(row, key, columnTypeMap) {
        const cell = row[key];
        if (cell === null)
            return;
        const columnType = columnTypeMap.get(key);
        if (!columnType)
            return;
        const fieldType = data_store_types_1.columnTypeToFieldType[columnType];
        if (!fieldType)
            return;
        const validationResult = (0, n8n_workflow_1.validateFieldType)(key, cell, fieldType, {
            strict: false,
            parseStrings: false,
        });
        if (!validationResult.valid) {
            throw new data_store_validation_error_1.DataStoreValidationError(`value '${String(cell)}' does not match column type '${columnType}': ${validationResult.errorMessage}`);
        }
        if (columnType === 'date') {
            try {
                const dateInISO = validationResult.newValue.toISO();
                row[key] = dateInISO;
                return;
            }
            catch {
                throw new data_store_validation_error_1.DataStoreValidationError(`value '${String(cell)}' does not match column type 'date'`);
            }
        }
        row[key] = validationResult.newValue;
    }
    async validateDataStoreExists(dataStoreId, projectId) {
        const existingTable = await this.dataStoreRepository.findOneBy({
            id: dataStoreId,
            project: {
                id: projectId,
            },
        });
        if (!existingTable) {
            throw new data_store_not_found_error_1.DataStoreNotFoundError(dataStoreId);
        }
        return existingTable;
    }
    async validateColumnExists(dataTableId, columnId) {
        const existingColumn = await this.dataStoreColumnRepository.findOneBy({
            id: columnId,
            dataTableId,
        });
        if (existingColumn === null) {
            throw new data_store_column_not_found_error_1.DataStoreColumnNotFoundError(dataTableId, columnId);
        }
        return existingColumn;
    }
    async validateUniqueName(name, projectId) {
        const hasNameClash = await this.dataStoreRepository.existsBy({
            name,
            projectId,
        });
        if (hasNameClash) {
            throw new data_store_name_conflict_error_1.DataStoreNameConflictError(name);
        }
    }
    validateAndTransformFilters(filterObject, columns) {
        this.validateRowsWithColumns(filterObject.filters.map((f) => {
            return {
                [f.columnName]: f.value,
            };
        }), columns, true);
        for (const filter of filterObject.filters) {
            if (['like', 'ilike'].includes(filter.condition)) {
                if (filter.value === null || filter.value === undefined) {
                    throw new data_store_validation_error_1.DataStoreValidationError(`${filter.condition.toUpperCase()} filter value cannot be null or undefined`);
                }
                if (typeof filter.value !== 'string') {
                    throw new data_store_validation_error_1.DataStoreValidationError(`${filter.condition.toUpperCase()} filter value must be a string`);
                }
                if (!filter.value.includes('%')) {
                    filter.value = `%${filter.value}%`;
                }
            }
            if (['gt', 'gte', 'lt', 'lte'].includes(filter.condition)) {
                if (filter.value === null || filter.value === undefined) {
                    throw new data_store_validation_error_1.DataStoreValidationError(`${filter.condition.toUpperCase()} filter value cannot be null or undefined`);
                }
            }
        }
    }
};
exports.DataStoreService = DataStoreService;
exports.DataStoreService = DataStoreService = __decorate([
    (0, di_1.Service)(),
    __metadata("design:paramtypes", [data_store_repository_1.DataStoreRepository,
        data_store_column_repository_1.DataStoreColumnRepository,
        data_store_rows_repository_1.DataStoreRowsRepository,
        backend_common_1.Logger])
], DataStoreService);
//# sourceMappingURL=data-store.service.js.map