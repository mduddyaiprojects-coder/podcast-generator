import { ContentSubmission } from '../models/content-submission';
import { PodcastEpisode } from '../models/podcast-episode';
import { logger } from '../utils/logger';
import { Pool, PoolClient } from 'pg';

export class DatabaseService {
  private pool: Pool;

  constructor() {
    // Use DATABASE_URL if available, otherwise fall back to individual variables
    const databaseUrl = process.env['DATABASE_URL'];
    
    const poolConfig = {
      // Connection pool settings optimized for Azure Functions Consumption Plan
      max: 2,  // Maximum number of clients in the pool (reduced from 10)
      min: 1,  // Minimum number of clients in the pool (reduced from 2)
      idleTimeoutMillis: 10000, // Close idle clients after 10 seconds (reduced from 30)
      connectionTimeoutMillis: 5000, // Return an error after 5 seconds (reduced from 10)
      acquireTimeoutMillis: 5000, // Return an error after 5 seconds (reduced from 10)
    };
    
    if (databaseUrl) {
      this.pool = new Pool({
        connectionString: databaseUrl,
        ssl: { rejectUnauthorized: false },
        ...poolConfig
      });
    } else {
      // Fallback to individual environment variables
      this.pool = new Pool({
        host: process.env['DATABASE_HOST'] || 'localhost',
        port: parseInt(process.env['DATABASE_PORT'] || '5432'),
        database: process.env['DATABASE_NAME'] || 'podcast_generator_dev',
        user: process.env['DATABASE_USER'] || 'postgres',
        password: process.env['DATABASE_PASSWORD'] || 'password',
        ssl: process.env['NODE_ENV'] === 'production' ? { rejectUnauthorized: false } : false,
        ...poolConfig
      });
    }

    // Handle pool errors
    this.pool.on('error', (err) => {
      logger.error('Unexpected error on idle client', err);
    });
  }

  async connect(): Promise<void> {
    try {
      // Test the pool connection
      const client = await this.pool.connect();
      await client.query('SELECT 1');
      client.release();
      logger.info('Database pool connected successfully');
    } catch (error) {
      logger.error('Database pool connection failed:', error);
      throw error;
    }
  }

  async disconnect(): Promise<void> {
    await this.pool.end();
  }

  // Helper method to execute queries with proper connection management
  private async executeQuery<T>(queryFn: (client: PoolClient) => Promise<T>): Promise<T> {
    const client = await this.pool.connect();
    try {
      return await queryFn(client);
    } finally {
      client.release();
    }
  }

  async saveSubmission(submission: ContentSubmission): Promise<string> {
    return this.executeQuery(async (client) => {
      const query = `
        INSERT INTO content_submissions (
          id, content_url, content_type, user_note, status, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id
      `;
      
      const values = [
        submission.id,
        submission.content_url,
        submission.content_type,
        submission.user_note,
        submission.status,
        submission.created_at,
        submission.updated_at
      ];

      const result = await client.query(query, values);
      logger.info('Submission saved to database:', submission.id);
      return result.rows[0].id;
    });
  }


  async saveEpisode(episode: PodcastEpisode): Promise<PodcastEpisode> {
    return this.executeQuery(async (client) => {
      const query = `
        INSERT INTO podcast_episodes (
          id, submission_id, title, description, source_url, content_type,
          audio_url, audio_duration, audio_size, transcript, dialogue_script,
          summary, chapter_markers, pub_date, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
      `;
      
      const values = [
        episode.id,
        episode.submission_id,
        episode.title,
        episode.description,
        episode.source_url,
        episode.content_type,
        episode.audio_url,
        episode.audio_duration,
        episode.audio_size,
        episode.transcript,
        episode.dialogue_script,
        episode.summary,
        episode.chapter_markers ? JSON.stringify(episode.chapter_markers) : null,
        episode.pub_date,
        episode.created_at,
        episode.updated_at
      ];

      await client.query(query, values);
      logger.info('Episode saved to database:', episode.id);
      return episode;
    });
  }

  async updateEpisode(episodeId: string, updates: Partial<PodcastEpisode>): Promise<void> {
    return this.executeQuery(async (client) => {
      const fields = [];
      const values = [];
      let paramCount = 1;

      if (updates.audio_url !== undefined) {
        fields.push(`audio_url = $${paramCount++}`);
        values.push(updates.audio_url);
      }

      if (updates.title !== undefined) {
        fields.push(`title = $${paramCount++}`);
        values.push(updates.title);
      }

      if (updates.description !== undefined) {
        fields.push(`description = $${paramCount++}`);
        values.push(updates.description);
      }

      if (fields.length === 0) {
        throw new Error('No fields to update');
      }

      fields.push(`updated_at = NOW()`);
      values.push(episodeId);

      const query = `UPDATE podcast_episodes SET ${fields.join(', ')} WHERE id = $${paramCount}`;
      await client.query(query, values);
      logger.info(`Updated episode ${episodeId}`);
    });
  }

  async getEpisodes(limit?: number, offset?: number): Promise<PodcastEpisode[]> {
    return this.executeQuery(async (client) => {
      let query = `
        SELECT id, submission_id, title, description, source_url, content_type,
               audio_url, audio_duration, audio_size, transcript, dialogue_script,
               summary, chapter_markers, pub_date, created_at, updated_at
        FROM podcast_episodes
        ORDER BY pub_date DESC
      `;
      
      const values: any[] = [];
      
      if (limit) {
        query += ` LIMIT $${values.length + 1}`;
        values.push(limit);
      }
      
      if (offset) {
        query += ` OFFSET $${values.length + 1}`;
        values.push(offset);
      }

      const result = await client.query(query, values);
      
      return result.rows.map(row => new PodcastEpisode({
        id: row.id,
        submission_id: row.submission_id,
        title: row.title,
        description: row.description,
        source_url: row.source_url,
        content_type: row.content_type,
        audio_url: row.audio_url,
        audio_duration: row.audio_duration,
        audio_size: row.audio_size,
        transcript: row.transcript,
        dialogue_script: row.dialogue_script,
        summary: row.summary,
        chapter_markers: row.chapter_markers,
        pub_date: row.pub_date,
        created_at: row.created_at,
        updated_at: row.updated_at
      }));
    });
  }

  async getEpisodeCount(): Promise<number> {
    return this.executeQuery(async (client) => {
      const query = 'SELECT COUNT(*) as count FROM podcast_episodes';
      const result = await client.query(query);
      return parseInt(result.rows[0].count);
    });
  }

  async checkConnection(): Promise<boolean> {
    try {
      return await this.executeQuery(async (client) => {
        await client.query('SELECT 1');
        return true;
      });
    } catch (error) {
      logger.error('Database connection check failed:', error);
      return false;
    }
  }

  // Content Submission methods
  async getSubmission(submissionId: string): Promise<ContentSubmission | null> {
    try {
      return await this.executeQuery(async (client) => {
        const query = 'SELECT * FROM content_submissions WHERE id = $1';
        const result = await client.query(query, [submissionId]);
        
        if (result.rows.length === 0) {
          return null;
        }

        const row = result.rows[0];
        return new ContentSubmission({
          id: row.id,
          content_url: row.content_url,
          content_type: row.content_type,
          user_note: row.user_note,
          status: row.status,
          created_at: row.created_at,
          updated_at: row.updated_at,
          processed_at: row.processed_at
        });
      });
    } catch (error) {
      logger.error('Failed to get submission:', error);
      return null;
    }
  }

  async updateSubmissionStatus(submissionId: string, status: string): Promise<void> {
    return this.executeQuery(async (client) => {
      const query = 'UPDATE content_submissions SET status = $1, updated_at = NOW() WHERE id = $2';
      await client.query(query, [status, submissionId]);
      logger.info(`Updated submission ${submissionId} status to ${status}`);
    });
  }

  // Processing Job methods
  async saveProcessingJob(job: any): Promise<void> {
    return this.executeQuery(async (client) => {
      const query = `
        INSERT INTO processing_jobs (
          id, submission_id, status, progress, current_step, 
          error_message, retry_count, max_retries, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        ON CONFLICT (id) DO UPDATE SET
          status = EXCLUDED.status,
          progress = EXCLUDED.progress,
          current_step = EXCLUDED.current_step,
          error_message = EXCLUDED.error_message,
          retry_count = EXCLUDED.retry_count,
          updated_at = EXCLUDED.updated_at
      `;
      
      await client.query(query, [
        job.id,
        job.submission_id,
        job.status,
        job.progress,
        job.current_step,
        job.error_message,
        job.retry_count,
        job.max_retries,
        job.created_at,
        job.updated_at
      ]);
    });
  }

  async getProcessingJob(jobId: string): Promise<any | null> {
    try {
      return await this.executeQuery(async (client) => {
        const query = 'SELECT * FROM processing_jobs WHERE id = $1';
        const result = await client.query(query, [jobId]);
        return result.rows.length > 0 ? result.rows[0] : null;
      });
    } catch (error) {
      logger.error('Failed to get processing job:', error);
      return null;
    }
  }

  async getProcessingJobBySubmissionId(submissionId: string): Promise<any | null> {
    try {
      return await this.executeQuery(async (client) => {
        const query = 'SELECT * FROM processing_jobs WHERE submission_id = $1 ORDER BY created_at DESC LIMIT 1';
        const result = await client.query(query, [submissionId]);
        return result.rows.length > 0 ? result.rows[0] : null;
      });
    } catch (error) {
      logger.error('Failed to get processing job by submission ID:', error);
      return null;
    }
  }

  async getProcessingJobsBySubmissionId(submissionId: string): Promise<any[]> {
    try {
      return await this.executeQuery(async (client) => {
        const query = 'SELECT * FROM processing_jobs WHERE submission_id = $1 ORDER BY created_at DESC';
        const result = await client.query(query, [submissionId]);
        return result.rows;
      });
    } catch (error) {
      logger.error('Failed to get processing jobs by submission ID:', error);
      return [];
    }
  }

  async getProcessingJobsByStatus(status: string): Promise<any[]> {
    try {
      return await this.executeQuery(async (client) => {
        const query = 'SELECT * FROM processing_jobs WHERE status = $1 ORDER BY created_at DESC';
        const result = await client.query(query, [status]);
        return result.rows;
      });
    } catch (error) {
      logger.error('Failed to get processing jobs by status:', error);
      return [];
    }
  }

  async getStaleProcessingJobs(olderThanHours: number): Promise<any[]> {
    try {
      return await this.executeQuery(async (client) => {
        const query = `
          SELECT * FROM processing_jobs 
          WHERE status IN ('queued', 'running') 
          AND created_at < NOW() - INTERVAL '${olderThanHours} hours'
          ORDER BY created_at ASC
        `;
        const result = await client.query(query);
        return result.rows;
      });
    } catch (error) {
      logger.error('Failed to get stale processing jobs:', error);
      return [];
    }
  }

  async cleanupOldProcessingJobs(olderThanDays: number): Promise<number> {
    try {
      return await this.executeQuery(async (client) => {
        const query = `
          DELETE FROM processing_jobs 
          WHERE status IN ('completed', 'failed') 
          AND updated_at < NOW() - INTERVAL '${olderThanDays} days'
        `;
        const result = await client.query(query);
        return result.rowCount || 0;
      });
    } catch (error) {
      logger.error('Failed to cleanup old processing jobs:', error);
      return 0;
    }
  }

  async getProcessingJobStatistics(): Promise<any> {
    try {
      return await this.executeQuery(async (client) => {
        const query = `
          SELECT 
            COUNT(*) as total,
            COUNT(CASE WHEN status = 'queued' THEN 1 END) as pending,
            COUNT(CASE WHEN status = 'running' THEN 1 END) as running,
            COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed,
            COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed
          FROM processing_jobs
        `;
        const result = await client.query(query);
        return result.rows[0];
      });
    } catch (error) {
      logger.error('Failed to get processing job statistics:', error);
      return { total: 0, pending: 0, running: 0, completed: 0, failed: 0 };
    }
  }

  // Episode methods
  async getEpisodeBySubmissionId(submissionId: string): Promise<any | null> {
    try {
      return await this.executeQuery(async (client) => {
        const query = 'SELECT * FROM podcast_episodes WHERE submission_id = $1';
        const result = await client.query(query, [submissionId]);
        return result.rows.length > 0 ? result.rows[0] : null;
      });
    } catch (error) {
      logger.error('Failed to get episode by submission ID:', error);
      return null;
    }
  }

  // Branding methods (T022 - Feature 002)
  /**
   * Get current branding from global_feed table
   * Uses the singleton global_feed record (id = 00000000-0000-0000-0000-000000000000)
   */
  async getBranding(): Promise<{
    title: string;
    imageUrl: string;
    updatedAt: Date;
  } | null> {
    try {
      return await this.executeQuery(async (client) => {
        const query = `
          SELECT title, artwork_url, updated_at
          FROM global_feed
          WHERE id = '00000000-0000-0000-0000-000000000000'::uuid
        `;
        const result = await client.query(query);
        
        if (result.rows.length === 0) {
          logger.warn('No global_feed record found');
          return null;
        }

        const row = result.rows[0];
        return {
          title: row.title,
          imageUrl: row.artwork_url || '',
          updatedAt: row.updated_at
        };
      });
    } catch (error) {
      logger.error('Failed to get branding from database:', error);
      return null;
    }
  }

  /**
   * Update branding in global_feed table with Last-Write-Wins (LWW) policy
   * Updates only the fields provided (partial update support)
   * Returns updated branding
   */
  async updateBranding(updates: {
    title?: string;
    imageUrl?: string;
    updatedBy?: string;
  }): Promise<{
    title: string;
    imageUrl: string;
    updatedAt: Date;
  }> {
    return this.executeQuery(async (client) => {
      const fields: string[] = [];
      const values: any[] = [];
      let paramCount = 1;

      // Build dynamic update query based on provided fields
      if (updates.title !== undefined) {
        fields.push(`title = $${paramCount++}`);
        values.push(updates.title);
      }

      if (updates.imageUrl !== undefined) {
        fields.push(`artwork_url = $${paramCount++}`);
        values.push(updates.imageUrl);
      }

      // Always update the updated_at timestamp (LWW policy - FR-017)
      fields.push(`updated_at = NOW()`);

      if (fields.length === 1) {
        // Only updated_at was added, no actual updates
        throw new Error('No fields to update in branding');
      }

      // Update the singleton global_feed record
      const query = `
        UPDATE global_feed 
        SET ${fields.join(', ')}
        WHERE id = '00000000-0000-0000-0000-000000000000'::uuid
        RETURNING title, artwork_url, updated_at
      `;

      const result = await client.query(query, values);
      
      if (result.rows.length === 0) {
        throw new Error('Failed to update branding: global_feed record not found');
      }

      const row = result.rows[0];
      logger.info('Branding updated in database', {
        title: row.title,
        imageUrl: row.artwork_url,
        updatedAt: row.updated_at,
        changedFields: Object.keys(updates).filter(k => updates[k as keyof typeof updates] !== undefined)
      });

      return {
        title: row.title,
        imageUrl: row.artwork_url || '',
        updatedAt: row.updated_at
      };
    });
  }
}
